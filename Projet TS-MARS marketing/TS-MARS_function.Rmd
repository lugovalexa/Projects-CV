---
title: "ts-mars-function"
author: "Elizaveta Golovanova, Alexandra Lugova, Joao Brum"
date: "2023-03-05"
output:
  html_document: 
    self_contained: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

source("libraries.R")
source("function.R")
source("mars_choice.R")
source("best_model_results.R")
source("best_model_visualisation.R")
source("compare_models.R")
```

This document is prepared to make MARS model estimations and visualizations easily, with a user-friendly interface. First, follow the instructions below to upload your data and make some preliminary transformations. If you want to use an example dataset, just uncomment the corresponding lines of code.

```{r, warning=FALSE, message=FALSE}
# Please, add your dataset here

#DataFrame <- read_excel('datasets/data_example_1.xlsx') %>% clean_names()
#DataFrame <- read_csv('datasets/data_example_2.csv') %>% clean_names()
#DataFrame <- read_excel('datasets/data_example_3.xlsx') %>% clean_names() 
#DataFrame <- read_excel('datasets/data_example_4.xlsx') %>% clean_names()

DataFrame <- read_excel('datasets/data_example_5.xlsx') %>% clean_names()

# Select the variables to explain your target variable

#variables <- c('x1', 'ventes_boisson_a_client', 'grp_presse','grp_tv','pression_cine', 'promotion_parfum_1_gratuit', 'promotion_parfum_2_prix', 'promotion_parfum_3_prix') #example 1
#variables <- c('week_start', 'sales', 'impressions_dm','impressions_auddig','impressions_inst', 'impressions_audtr', 'impressions_vidtr', 'impressions_viddig', 'impressions_so', 'impressions_on', 'impressions_em','impressions_sms','impressions_aff','impressions_sem') #example2
#variables <- c('date','annee', 'semaine', 'chiffre_daffaires_ht_k', 'temperature_constatee', 'temperature_normale_de_saison', 'affichage_indice_de_pression','catalogue_theme_1_indice_de_pression') #example3
#variables <- c('date', 'sales', 'tv_ad_budget', 'radio_ad_budget', 'newspaper_ad_budget') #example4

variables <- c('date','sales','media1', 'media2', 'media3') #example5
DataFrame <- DataFrame %>% select(all_of(variables))

# Replace "sales" with the name of your target variable

colnames(DataFrame)[colnames(DataFrame) == 'sales'] <- 'TimeSeries' #example 5

# Make formatting of you date column

colnames(DataFrame)[colnames(DataFrame) == 'date'] <- 'Date' # replace "date" with the name of your date column
DataFrame$Date <- as.Date(DataFrame$Date, format = "%Y-%m-%d") # set format argument according to your data

# If needed, transform some variables, such as indicators of promotion, into dummies

#DataFrame$variable_dummy <- ifelse(DataFrame$variable > 0, 1, 0)  

# Make any other transformation of variables you may need

#DataFrame$Temp_diff = DataFrame$temperature_constatee - DataFrame$temperature_normale_de_saison #example 3
```

To obtain the best and correct MARS model visualizations we offer to refer on several tests that take into account possible distortion of results : 

1. Checking for missing data and any inconsistencies in the data. The NaN values will be dropped automatically, and we suggest you to do manually the mistakes check. The model is known to be resistant to outliers, however, if they are too strong, consider to drop them.  

2. Remove trend if it is stongly visible with an option to use the breaking points. We'll offer you to see on graphic the structural breaking points detected using the Perron test and decide if those points are relevant. If yes, data will be split and trend will be removed from each part. 

3. Remove seasonality if it is stongly visible. We'll offer you to see it on graphics first and decide if you want it to be removed. In general, MARS model is resistant to slight seasonal fluctuations.

4. [Standartizing data](https://stats.stackexchange.com/questions/591269/is-data-scaling-necessary-in-mars-regression). We'll offer you to apply the standardization to all continuous variables in order to obtain comparable coefficients. However, it will affect the visualization, as the scales always will be in [0,1].

5. Autocorrelation test for lags in MARS model. When calculating the final model results we'll offer you to look at the ACF graphic to make your decision about adding some extra lags.

6. Multicollinearity test. When calculating the final model results a message will appear if there are highly correlated variables. You'll see all variables for which VIF indicator is more than 10. We also calculated the condition indices. A condition number between 10 and 30 indicates the presence of multicollinearity and when a value is larger than 30, the multicollinearity is regarded as strong. We set the threshold at 30.

Here we offer you to do some graphical tests before transforming data.

Do you see a strong seasonality on this graphic? If yes, please use the following parameter `drop_seas = TRUE` in the **main** function below.

```{r, warning=FALSE, echo=FALSE}
ggplot(DataFrame, aes(x = Date, y = TimeSeries)) +
  geom_line(color = "blue") +
  labs(x = "Date", y = "Value", title = "Time Series Data") +
  theme_bw() +
  theme(plot.title = element_text(hjust = 0.5),
        axis.title = element_text(size = 12),
        axis.text = element_text(size = 9),
        panel.grid.minor = element_blank(),
        panel.border = element_blank(),
        panel.background = element_blank()) +
  guides(color = 'None')
```

Do you see a breaking point on this graphic? If yes and you agree that there is a structural change at this point of time, please use the parameter `breaks` in the function below to indicate their number. 

If the graphic is not displayed, your data is stationary and there are no points of structural change. `breaks = 0` is set by default in the function below.

```{r, warning = FALSE, message=FALSE, echo=FALSE}
# Stationarity
## Augmented Dickeyâ€“Fuller (ADF) t-statistic test for unit root
if (adf.test(DataFrame$TimeSeries)$p.value > 0.05){
  ## Pettitt Test to detect a structural break
  pettittTest <- trend::pettitt.test(DataFrame$TimeSeries)
  if (pettittTest$p.value < 0.05) {
 # Add abline to the previous plot to show point of break
    ggplot(DataFrame, aes(x = Date, y = TimeSeries)) +
      geom_line(color = "blue") +
      geom_smooth(method = "loess", se = FALSE, color = "red") +
      labs(x = "Date", y = "Value", title = "Time Series Data and Trend with Structural Break Point") +
      theme_bw() +
      theme(plot.title = element_text(hjust = 0.5),
            axis.title = element_text(size = 12),
            axis.text = element_text(size = 9),
            panel.grid.minor = element_blank(),
            panel.border = element_blank(),
            panel.background = element_blank()) +
      guides(color = "None") +
      geom_vline(mapping = aes(xintercept = as.numeric(Date[pettittTest$estimate])),
                 linetype = 2,
                 colour = "red",
                 linewidth = 1)
  }
}
```

Now we suggest you to choose parameters for your model. Choose your parameters in the function `main`:

**drop_seas**
(Default `drop_seas = FALSE`)

Indicate if you want to clean your target variable from seasonality `drop_seas = TRUE`. If it's the case, please, indicate related variable in `related_var_season` from this list `c('seasonspring', 'seasonsummer', 'seasonfall', 'seasonwinter')`. By default, `related_var_season = seasonfall`. 

**LAG**
(Default `LAG = 0`)

Indicate if you want to add lags of your target variable `LAG = N` with N being the number of lags you want to add.

**standardize**
(Default `standardize = FALSE`)

You can also choose to standardize continuous variables in your data set by indicating `standardize = TRUE`.

**break**
(Default `break = 0`)

You can use the parameter `break=N` if you observe some structural breaks on the graphic above with N being the number of breaks you want to add.

**adStock**
(Default `adStock = FALSE`)

We also add the adStock transformation if you want to take into account the saturation of your advertisement during the time. If you want to use it, add `adStock = TRUE` and the list variables `variables_ads = c()` that you want to transform. 

We suggest you to build one model `DataFrame_base_dat` without any specific parameters and another with  your settings `DataFrame_feature_dat` to be able to compare them. You can also create more than two personalized models with different specifications of parameters.

```{r, message=FALSE, warning=FALSE}
DataFrame_base_dat = main(DataFrame)
DataFrame_feature_dat = main(
                            DataFrame, 
                            drop_seas = TRUE, related_var_season = 'seasonspring', 
                            LAG = 1
                          #  adStock = TRUE,
                          #  variables_ads = c("campaign1","campaign2","campaign3")
              )

DataFrame_base = DataFrame_base_dat %>% select(-Date)
DataFrame_feature = DataFrame_feature_dat %>% select(-Date)
```

If you want to compare models with different settings, use the function `mars_choice` below. You just need to insert a list of models. 

The `degree` parameter is always 2 since we are interested in looking at the synergy/antagony of advertisement and `nprune` parameter (coefficient shrinkage) is tuned for each model automatically. 

Be careful when comparing models with and without standardization, use relative indicators like MAPE and R2. 

You can also change the window size for predictions for the best parameters tuning, by default, `window_size = 30`.

```{r, message=FALSE, warning=FALSE}
mars_choice(list(DataFrame_base, DataFrame_feature), window_size = 50)
```

Here you can see the results for your best model, variable importance ranking and check the autocorrelation and multicollinearity test results. 

Add generated dataset with best set of parameters to `best_model_results` function. 

```{r, warning=FALSE}
best_model_dataset = DataFrame_base
## If there is an error, check if all your variables have non zero values
results = best_model_results(best_model_dataset, window_size = 50)
```

Here you can visualize results. You will see two plots: 1) a 3D plot, showing how different combinations of variables affect the target variable, and 2) a 2D plot, indicating the ranges of synergistic, antagonistic and zero effects of the chosen variables on the target variable.

Please, add a pair of variables that you want to visualize to test for a synergy effect. Sometimes there are no significant results in a model, thus, graphics can be not very informative. 

Synergy refers to combined effect of two variables that is greater than the sum of their individual effects. To define how much should the effect should be greater to be considered synergy (or lower to be considered antagonism), you can chose a synergy threshold by setting the `synergy_threshold` parameter of the function. For example, a synergy threshold of 0.01 means that if combined effect of two variables is 1% or more (less) than the sum of their individual effects, it will be considered as a synergistic (antagonistic) effect, and all combinations in between - as zero effect zones.

```{r, warning=FALSE}
best_model_visualisation(best_model_dataset, results, synergy_threshold = 0.01, variables =
                           #c('grp_presse', 'pression_cine')) #example 1
                           #c('impressions_vidtr', 'impressions_sem')) #example 2
                           #c("affichage_indice_de_pression", "catalogue_theme_1_indice_de_pression")) #example 3
                           #c("tv_ad_budget", "radio_ad_budget")) #example 4
                           c("media1","media2")) #example 5
```

The following table compares RMSE for our tuned MARS model to a regular multiple regression model along with tuned principal component regression (PCR), partial least squares (PLS), regularized regression (elastic net), random forest, gradient boosting models. By looking at the mean RMSE and their variance you can get an idea of whether the MARS model you built has the best performance for your data (the lower RMSE, the better the model).

```{r, message=FALSE, warning=FALSE}
# keep tight, this function contains training of several machine learning models so it can take quite some time to execute
compare_models(best_model_dataset)
```







